# @license GPL-3.0-or-later
# Copyright (C) 2025 Caleb Gyamfi - Omnixys Technologies
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# For more information, visit <https://www.gnu.org/licenses/>.

name: 🧪 E2E Authentication Tests

on:
  push:
    branches: [main, dev]
  workflow_dispatch:

env:
  OMNIXYS_ADMIN_USERNAME: ${{ secrets.OMNIXYS_ADMIN_USERNAME }}
  OMNIXYS_ADMIN_PASSWORD: ${{ secrets.OMNIXYS_ADMIN_PASSWORD }}
  OMNIXYS_USER_USERNAME: ${{ secrets.OMNIXYS_USER_USERNAME }}
  OMNIXYS_USER_PASSWORD: ${{ secrets.OMNIXYS_USER_PASSWORD }}
  OMNIXYS_EMAIL_DOMAIN: ${{ secrets.OMNIXYS_EMAIL_DOMAIN }}

  POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
  POSTGRES_SQL_HOST: postgres://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@localhost:5433/${{ secrets.POSTGRES_DB }}

  KAFKA_BROKER: ${{ secrets.KAFKA_BROKER }}
  TEMPO_URI: ${{ secrets.TEMPO_URI }}

  KC_ADMIN_USERNAME: ${{ secrets.KC_ADMIN_USERNAME }}
  KC_ADMIN_PASSWORD: ${{ secrets.KC_ADMIN_PASSWORD }}
  KC_URL: ${{ secrets.KC_TEST_URL }}
  KC_REALM: ${{ secrets.KC_REALM }}
  KC_CLIENT_ID: ${{ secrets.KC_CLIENT_ID }}
  KC_CLIENT_SECRET: ${{ secrets.KC_CLIENT_SECRET }}

  KEYS_PATH: ${{ secrets.KEYS_PATH }}
  SERVICE: ${{ secrets.SERVICE }}
  PORT: ${{ secrets.PORT }}
  GRAPHQL_PLAYGROUND: ${{ secrets.GRAPHQL_PLAYGROUND }}
  NODE_ENV: ${{ secrets.NODE_ENV }}
  HTTPS: ${{ secrets.HTTPS }}

  LOG_LEVEL: ${{ secrets.LOG_LEVEL }}
  LOG_PRETTY: ${{ secrets.LOG_PRETTY }}
  LOG_DEFAULT: ${{ secrets.LOG_DEFAULT }}
  LOG_DIRECTORY: ${{ secrets.LOG_DIRECTORY }}
  LOG_FILE_DEFAULT_NAME: ${{ secrets.LOG_FILE_DEFAULT_NAME }}

  REDIS_HOST: ${{ secrets.REDIS_HOST }}
  REDIS_PORT: ${{ secrets.REDIS_PORT }}
  REDIS_USERNAME: ${{ secrets.REDIS_USERNAME }}
  REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
  REDIS_PC_JWE_KEY: ${{ secrets.REDIS_PC_JWE_KEY }}
  REDIS_PC_TTL_SEC: ${{ secrets.REDIS_PC_TTL_SEC }}

  POSTGRES_TEST_USER: ${{ secrets.POSTGRES_TEST_USER }}
  POSTGRES_TEST_PASSWORD: ${{ secrets.POSTGRES_TEST_PASSWORD }}
  POSTGRES_TEST_DB: ${{ secrets.POSTGRES_TEST_DB }}
  POSTGRES_TEST_URL: postgres://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@localhost:5433/${{ secrets.POSTGRES_DB }}

jobs:
  e2e:
    name: Run Auth E2E Tests
    runs-on: ubuntu-latest
    timeout-minutes: 25

    strategy:
      fail-fast: false
      matrix:
        node-version: [24.10.0]
        redis-version: [7]
        postgres-version: [18]
        # test-type: [login, signup, user, admin]

    services:
      postgres:
        image: postgres:${{ matrix.postgres-version }}
        env:
          POSTGRES_USER: ${{ env.POSTGRES_TEST_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_TEST_PASSWORD }}
          POSTGRES_DB: ${{ env.POSTGRES_TEST_DB }}
        ports:
          - 5433:5432
        options: >-
          --health-cmd "pg_isready -U auth"
          --health-interval 5s
          --health-timeout 3s
          --health-retries 10

      redis:
        image: redis:${{ matrix.redis-version }}
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 5s
          --health-timeout 3s
          --health-retries 10

      zookeeper:
        image: wurstmeister/zookeeper
        ports:
          - 2181:2181
        env:
          ALLOW_ANONYMOUS_LOGIN: yes
        options: >-
          --health-cmd "echo ruok | nc localhost 2181 | grep imok"
          --health-interval 5s
          --health-timeout 3s
          --health-retries 10

      kafka:
        image: wurstmeister/kafka
        env:
          KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092
          KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
          KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
          KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
        ports:
          - 9092:9092
        options: >-
          --hostname kafka
          --health-cmd "bash -c 'nc -z localhost 9092 || exit 1'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 15
          --health-start-period 20s

    steps:
      - name: 🛎️ Checkout repository
        uses: actions/checkout@v4

      - name: ⚙️ Enable Corepack (pnpm)
        run: |
          corepack enable
          corepack prepare pnpm@latest --activate

      - name: ⚙️ Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'pnpm'

      - name: ♻️ Restore pnpm cache
        uses: actions/cache@v4
        with:
          path: ~/.pnpm-store
          key: pnpm-${{ runner.os }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-${{ runner.os }}-

      - name: 📦 Install dependencies
        run: |
          corepack enable
          pnpm install --frozen-lockfile

      - name: 🚀 Start Keycloak (26.3.2)
        run: |
          docker run -d --name keycloak -p 18080:8080 \
           -e KC_BOOTSTRAP_ADMIN_USERNAME=${{ env.KC_ADMIN_USERNAME }} \
           -e KC_BOOTSTRAP_ADMIN_PASSWORD=${{ env.KC_ADMIN_PASSWORD }} \
           -v "$(pwd)/__tests__/keycloak/camunda-platform-realm.json:/opt/keycloak/data/import/camunda-platform-realm.json:ro" \
           --tmpfs /opt/keycloak/data:rw,size=200m \
           quay.io/keycloak/keycloak:26.3.2 \
           start-dev --import-realm --http-port=8080


          echo "⏳ Waiting for Keycloak..."
          for i in {1..40}; do
            if  curl -fs http://localhost:18080/realms/master >/dev/null 2>&1; then
              echo "✅ Base realm 'master' available (after $i checks)"
              break
            fi
            echo "waiting for master realm ($i/40)..."
            sleep 5
          done

          echo "⏳ Waiting for imported realm 'camunda-platform'..."
          for i in {1..60}; do
            status=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Accept: application/json" \
              http://localhost:18080/realms/camunda-platform || echo 000)

            if [ "$status" = "200" ]; then
              echo "✅ Realm 'camunda-platform' reachable (HTTP $status after $i tries)"
              docker ps
              exit 0
            fi

            echo "Realm not yet reachable (status $status, try $i/60)..."
            sleep 5
          done

          echo "❌ Keycloak did not become ready in time. Dumping logs..."
          docker logs keycloak
          exit 1

      - name: 🧪 Run E2E Auth Tests
        run: |
          pnpm run build
          pnpm run test:e2e:auth
  
      - name: 🧾 Upload Test Logs (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-auth-logs
          path: ./__tests__/reports/

      - name: 📊 Upload Coverage Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-auth-coverage
          path: __tests__/reports/e2e/coverage/

      - name: 🧾 Append Coverage Summary
        if: always()
        run: |
          echo "### 🧪 E2E Test Summary" >> $GITHUB_STEP_SUMMARY
          SUMMARY_FILE="./__tests__/reports/e2e/coverage/coverage-summary.json"
      
          if [ -f "$SUMMARY_FILE" ]; then
            echo '```' >> $GITHUB_STEP_SUMMARY
            node -e "
            const fs = require('fs');
            const summary = JSON.parse(fs.readFileSync('$SUMMARY_FILE', 'utf8'));
            const total = summary.total;
            for (const [key, value] of Object.entries(total)) {
              const pct = value.pct?.toString().padStart(6, ' ');
              console.log(\`\${key.padEnd(12)}: \${pct}% (\${value.covered}/\${value.total})\`);
            }
            " >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
      
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Metric | % | Covered | Total |" >> $GITHUB_STEP_SUMMARY
            echo "|:--|--:|--:|--:|" >> $GITHUB_STEP_SUMMARY
            node -e "
            const fs = require('fs');
            const s = JSON.parse(fs.readFileSync('$SUMMARY_FILE', 'utf8')).total;
            for (const [k, v] of Object.entries(s)) {
              console.log(\`| \${k} | \${v.pct}% | \${v.covered} | \${v.total} |\`);
            }
            " >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ No coverage report generated" >> $GITHUB_STEP_SUMMARY
          fi


      - name: 🪶 Generate Coverage Badge
        if: always()
        run: |
          mkdir -p coverage
          cp __tests__/reports/e2e/coverage/coverage-summary.json coverage/
          npx make-coverage-badge \
            --input __tests__/reports/e2e/coverage/lcov.info \
            --output __tests__/reports/e2e/coverage/coverage.svg
        continue-on-error: true

      - name: 📤 Upload Coverage Badge
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-badge
          path: ./coverage/badge.svg

      - name: 💾 Commit Coverage Badge to Repo
        if: success()
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git fetch origin main
          git checkout main
          cp ./coverage/badge.svg .extras/badge/coverage.svg
          git add .extras/badge/coverage.svg 
          git commit -m "ci: update coverage badge [skip ci]" || echo "No changes to commit"
          git push origin main

