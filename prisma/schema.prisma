generator client {
  provider = "prisma-client"
  output   = "../src/prisma/generated"
}

datasource db {
  provider = "postgresql"
  schemas  = ["authentication"]
}

enum MfaPreference {
  NONE
  TOTP
  WEBAUTHN
  BACKUP_CODES
  SECURITY_QUESTIONS

  @@map("mfa_preference")
  @@schema("authentication")
}

enum ResetTokenState {
  ISSUED
  TOKEN_VERIFIED
  STEPUP_VERIFIED
  COMPLETED
  LOCKED
  EXPIRED

  @@map("reset_token_state")
  @@schema("authentication")
}

model AuthUser {
  id            String        @id @default(uuid())
  email         String        @unique
  mfaPreference MfaPreference @default(NONE)

  failedAttempts Int       @default(0)
  lockedUntil    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  totp              TotpCredential?
  webAuthn          WebAuthnCredential[]
  backupCodes       BackupCode[]
  securityQuestions SecurityQuestion[]
  resetTokens       PasswordResetToken[]
  knownDevices      KnownDevice[]
  loginHistories    LoginHistory[]

  @@map("auth_user")
  @@schema("authentication")
}

model TotpCredential {
  id              String  @id @default(uuid())
  encryptedSecret String
  enabled         Boolean @default(false)

  userId String   @unique
  user   AuthUser @relation(fields: [userId], references: [id])

  @@map("totp_credential")
  @@schema("authentication")
}

model WebAuthnCredential {
  id           String  @id @default(uuid())
  credentialId String  @unique
  publicKey    String
  counter      Int
  deviceType   String
  backedUp     Boolean
  transports   String?

  nickname   String? // ðŸ‘ˆ user-defined name
  createdAt  DateTime  @default(now())
  lastUsedAt DateTime?
  revokedAt  DateTime?

  user   AuthUser @relation(fields: [userId], references: [id])
  userId String

  @@map("web_auth_n_credentials")
  @@schema("authentication")
}

model BackupCode {
  id       String    @id @default(uuid())
  codeHash String
  usedAt   DateTime?

  userId String
  user   AuthUser @relation(fields: [userId], references: [id])

  @@map("backup_code")
  @@schema("authentication")
}

model SecurityQuestion {
  id         String   @id @default(uuid())
  question   String
  answerHash String
  user       AuthUser @relation(fields: [userId], references: [id])
  userId     String

  @@map("security_question")
  @@schema("authentication")
}

model PasswordResetToken {
  id String @id @default(uuid())

  tokenHash       String
  tokenLookupHash String @unique

  state ResetTokenState @default(ISSUED)

  expiresAt DateTime
  attempts  Int       @default(0)
  locked    Boolean   @default(false)
  usedAt    DateTime?

  userId String
  user   AuthUser @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
  @@map("password_reset_token")
  @@schema("authentication")
}

model RateLimitBucket {
  id          String    @id @default(uuid())
  key         String    @unique
  windowStart DateTime
  count       Int
  lockedUntil DateTime?

  @@map("rate_limit_bucket")
  @@schema("authentication")
}

model KnownDevice {
  id          String   @id @default(uuid())
  userId      String
  fingerprint String
  firstSeen   DateTime @default(now())
  lastSeen    DateTime @updatedAt

  user AuthUser @relation(fields: [userId], references: [id])

  @@unique([userId, fingerprint])
  @@schema("authentication")
}

model LoginHistory {
  id        String   @id @default(uuid())
  userId    String
  ip        String
  country   String?
  city      String?
  createdAt DateTime @default(now())

  user AuthUser @relation(fields: [userId], references: [id])

  @@index([userId])
  @@schema("authentication")
}
